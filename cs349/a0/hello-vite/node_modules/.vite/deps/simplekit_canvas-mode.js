// node_modules/simplekit/src/events/events.ts
var SKEvent = class {
  constructor(type, timeStamp, source) {
    this.type = type;
    this.timeStamp = timeStamp;
    this.source = source;
  }
};
var SKMouseEvent = class extends SKEvent {
  constructor(type, timeStamp, x, y, source) {
    super(type, timeStamp, source);
    this.x = x;
    this.y = y;
  }
};
var SKKeyboardEvent = class extends SKEvent {
  constructor(type, timeStamp, key = null, source) {
    super(type, timeStamp, source);
    this.key = key;
  }
};
var SKResizeEvent = class extends SKEvent {
  constructor(type, timeStamp, width, height, source) {
    super(type, timeStamp, source);
    this.width = width;
    this.height = height;
  }
};

// node_modules/simplekit/src/utility/misc.ts
function distance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
}

// node_modules/simplekit/src/events/translators.ts
var fundamentalTranslator = {
  update(fe) {
    switch (fe.type) {
      case "mousedown":
      case "mouseup":
      case "mousemove":
        return new SKMouseEvent(
          fe.type,
          fe.timeStamp,
          fe.x || 0,
          fe.y || 0
        );
        break;
      case "keydown":
      case "keyup":
        return new SKKeyboardEvent(fe.type, fe.timeStamp, fe.key);
        break;
      case "resize":
        return new SKResizeEvent(
          fe.type,
          fe.timeStamp,
          document.body.clientWidth,
          document.body.clientHeight
        );
      case "null":
        return;
      default:
        return new SKEvent(fe.type, fe.timeStamp);
    }
  }
};
var clickTranslator = {
  state: "IDLE",
  // parameters for transitions
  movementThreshold: 10,
  timeThreshold: 800,
  // milliseconds
  // for tracking thresholds
  startX: 0,
  startY: 0,
  startTime: 0,
  // returns a click event if found
  update(fe) {
    switch (this.state) {
      case "IDLE":
        if (fe.type == "mousedown") {
          this.state = "DOWN";
          this.startX = fe.x || 0;
          this.startY = fe.y || 0;
          this.startTime = fe.timeStamp;
        }
        break;
      case "DOWN":
        if (fe.timeStamp - this.startTime > this.timeThreshold) {
          this.state = "IDLE";
        } else if (fe.x && fe.y && distance(fe.x, fe.y, this.startX, this.startY) > this.movementThreshold) {
          this.state = "IDLE";
        } else if (fe.type == "mouseup") {
          this.state = "IDLE";
          return new SKMouseEvent(
            "click",
            fe.timeStamp,
            fe.x || 0,
            fe.y || 0
          );
        }
        break;
    }
    return;
  }
};
var dblclickTranslator = {
  // internal click translator for dblclick
  // note this is a copy of main clickTranslator object
  internalClickTranslator: { ...clickTranslator },
  state: "IDLE",
  // parameters for transitions
  timeThreshold: 500,
  // milliseconds
  // for tracking thresholds
  startTime: 0,
  // returns a dblclick event if found
  // needs a click event as well, the fe event is for time
  update(fe) {
    const e = this.internalClickTranslator.update(fe);
    switch (this.state) {
      case "IDLE":
        if (e && e.type == "click") {
          this.state = "READY";
          this.startTime = e.timeStamp;
        }
        break;
      case "READY":
        if (fe.timeStamp - this.startTime > this.timeThreshold) {
          this.state = "IDLE";
        } else if (e && e.type == "click") {
          this.state = "IDLE";
          return new SKMouseEvent(
            "dblclick",
            fe.timeStamp,
            fe.x || 0,
            fe.y || 0
          );
        }
        break;
    }
    return;
  }
};
var dragTranslator = {
  state: "IDLE",
  // parameters for transitions
  movementThreshold: 20,
  // for tracking thresholds
  startX: 0,
  startY: 0,
  // returns a drag event if found
  update(fe) {
    switch (this.state) {
      case "IDLE":
        if (fe.type == "mousedown") {
          this.state = "DOWN";
          this.startX = fe.x || 0;
          this.startY = fe.y || 0;
        }
        break;
      case "DOWN":
        if (fe.type == "mouseup") {
          this.state = "IDLE";
        } else if (fe.type == "mousemove" && fe.x && fe.y && distance(fe.x, fe.y, this.startX, this.startY) > this.movementThreshold) {
          this.state = "DRAG";
          return {
            type: "dragstart",
            timeStamp: fe.timeStamp,
            x: fe.x,
            y: fe.y
          };
        }
        break;
      case "DRAG":
        if (fe.type == "mousemove") {
          return {
            type: "drag",
            timeStamp: fe.timeStamp,
            x: fe.x,
            y: fe.y
          };
        } else if (fe.type == "mouseup") {
          this.state = "IDLE";
          return {
            type: "dragend",
            timeStamp: fe.timeStamp,
            x: fe.x,
            y: fe.y
          };
        }
        break;
    }
    return;
  }
};

// node_modules/simplekit/src/windowing-system/windowing-system.ts
function createFundamentalEvent(domEvent) {
  if (domEvent.type == "resize") {
    return {
      type: domEvent.type,
      timeStamp: domEvent.timeStamp,
      width: document.body.clientWidth,
      height: document.body.clientHeight
    };
  } else if (domEvent.type == "mouseup" || domEvent.type == "mousedown" || domEvent.type == "mousemove") {
    const me = domEvent;
    return {
      type: domEvent.type,
      timeStamp: domEvent.timeStamp,
      x: me.x,
      y: me.y
    };
  } else if (domEvent.type == "keyup" || domEvent.type == "keydown") {
    const ke = domEvent;
    if (ke.repeat) return;
    return {
      type: domEvent.type,
      timeStamp: domEvent.timeStamp,
      key: ke.key
    };
  } else {
    console.warn(
      `event ${domEvent.type} not supported as FundamentalEvent`
    );
    return;
  }
}
function createWindowingSystem(runLoop2) {
  const eventQueue = [];
  function saveEvent(domEvent) {
    const fundamentalEvent = createFundamentalEvent(domEvent);
    if (!fundamentalEvent) return;
    eventQueue.push(fundamentalEvent);
  }
  window.addEventListener("mousedown", saveEvent);
  window.addEventListener("mouseup", saveEvent);
  window.addEventListener("mousemove", saveEvent);
  window.addEventListener("keydown", saveEvent);
  window.addEventListener("keyup", saveEvent);
  window.addEventListener("resize", saveEvent);
  const initialResizeEvent = createFundamentalEvent(
    new Event("resize")
  );
  if (initialResizeEvent) eventQueue.push(initialResizeEvent);
  function loop(time) {
    skTime = time;
    runLoop2(eventQueue, time);
    window.requestAnimationFrame(loop);
  }
  window.requestAnimationFrame(loop);
}
var skTime = 0;

// node_modules/simplekit/src/windowing-system/coalesce.ts
function coalesceEvents(events, eventTypes = ["mousemove", "resize"]) {
  const original = [...events];
  events.length = 0;
  original.forEach((e) => {
    if (e.type in eventTypes) {
      const i = events.findIndex((ee) => ee.type in eventTypes);
      if (i > -1) {
        events[i] = e;
      } else {
        events.push(e);
      }
    } else {
      events.push(e);
    }
  });
}

// node_modules/simplekit/src/common.ts
function checkHtml() {
  var _a;
  let isGood = true;
  if (document.body.children.length !== 1) {
    console.error(
      `document body has ${document.body.children.length} children, must have 1`
    );
    isGood = false;
  }
  if (!document.querySelector("body>script")) {
    console.error("document body must be a single <script> element");
    isGood = false;
  }
  if (document.querySelector("link[rel=stylesheet]")) {
    console.error("no <style> tags allowed");
    isGood = false;
  }
  const scripts = document.querySelectorAll(
    "head>script"
  );
  if (scripts.length > 1 || !((_a = scripts[0]) == null ? void 0 : _a.src.includes("vite/client"))) {
    console.error(
      "only 1 <script> tag allowed in head for Vite client"
    );
    isGood = false;
  }
  if (document.querySelector("link:not([rel=icon])")) {
    console.error(
      `only <link> allowed is 1 <link rel="icon" ...> in head`
    );
    isGood = false;
  }
  if (!isGood) {
    console.log(
      "ðŸ›‘ SimpleKit will not run with issues above. Fix HTML page hosting SimpleKit and/or disable browser plug-ins."
    );
  }
  return isGood;
}
function setupCanvas(colour = "whitesmoke") {
  let canvas = document.createElement("canvas");
  document.body.appendChild(canvas);
  canvas.style.setProperty("background", colour);
  document.documentElement.style.setProperty("width", "100%");
  document.documentElement.style.setProperty("height", "100%");
  document.documentElement.style.setProperty("margin", "0");
  document.documentElement.style.setProperty("padding", "0");
  document.body.style.setProperty("width", "100%");
  document.body.style.setProperty("height", "100%");
  document.body.style.setProperty("margin", "0");
  document.body.style.setProperty("padding", "0");
  canvas.style.setProperty("width", "100%");
  canvas.style.setProperty("height", "100%");
  canvas.style.setProperty("display", "block");
  canvas.width = document.body.clientWidth;
  canvas.height = document.body.clientHeight;
  window.addEventListener("resize", () => {
    canvas.width = document.body.clientWidth;
    canvas.height = document.body.clientHeight;
  });
  console.info(` created ${canvas.width} by ${canvas.height} canvas`);
  return canvas;
}

// node_modules/simplekit/package.json
var version = "0.5.0";

// node_modules/simplekit/src/canvas-mode.ts
function runLoop(eventQueue, time) {
  coalesceEvents(eventQueue);
  let events = [];
  if (eventQueue.length == 0) {
    eventQueue.push({
      type: "null",
      timeStamp: time
    });
  }
  while (eventQueue.length > 0) {
    const fundamentalEvent = eventQueue.shift();
    if (!fundamentalEvent) continue;
    translators.forEach((t) => {
      const translatedEvent = t.update(fundamentalEvent);
      if (translatedEvent) {
        events.push(translatedEvent);
      }
    });
  }
  if (eventListener) events.forEach((e) => eventListener(e));
  if (animateCallback) animateCallback(time);
  if (drawCallback) drawCallback(gc);
}
var gc;
var translators = [
  fundamentalTranslator,
  clickTranslator,
  dblclickTranslator,
  dragTranslator
];
function addSKEventTranslator(translator) {
  translators.push(translator);
  console.log(
    `added event translator, now ${translators.length} translators`
  );
}
function setSKEventListener(listener) {
  eventListener = listener;
}
var eventListener;
function setSKDrawCallback(draw) {
  drawCallback = draw;
}
var drawCallback;
function setSKAnimationCallback(animate) {
  animateCallback = animate;
}
var animateCallback;
function startSimpleKit() {
  console.info(
    `ðŸ§° SimpleKit v${version} *Canvas Mode* startup`
  );
  if (!checkHtml()) return false;
  let canvas = setupCanvas();
  const graphicsContext = canvas.getContext("2d");
  if (!graphicsContext) {
    console.error("Unable to get graphics context from canvas");
    return false;
  }
  gc = graphicsContext;
  createWindowingSystem(runLoop);
  return { width: gc.canvas.width, height: gc.canvas.height };
}
export {
  SKEvent,
  SKKeyboardEvent,
  SKMouseEvent,
  SKResizeEvent,
  addSKEventTranslator,
  clickTranslator,
  dblclickTranslator,
  dragTranslator,
  fundamentalTranslator,
  setSKAnimationCallback,
  setSKDrawCallback,
  setSKEventListener,
  skTime,
  startSimpleKit
};
//# sourceMappingURL=simplekit_canvas-mode.js.map
